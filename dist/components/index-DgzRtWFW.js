"use strict";const c=require("./base-component-_c7CmBvl.js");var l="1.1.0";const m=["all","intersecting","update"],_="PositionObserver Error";var d=class{entries;static version=l;_t;_r;_cm;_w;_h;_rm;_th;_c;constructor(t,e){if(!c.xo(t))throw new Error(`${_}: ${t} is not a function.`);this.entries=new Map,this._c=t,this._t=0;const i=c.i(e?.root)?e.root:document?.documentElement;this._r=i,this._rm=e?.rootMargin,this._th=e?.threshold;this._cm=m.indexOf(e?.callbackMode||"intersecting"),this._w=i.clientWidth,this._h=i.clientHeight}observe=t=>{if(!c.i(t))throw new Error(`${_}: ${t} is not an instance of Element.`);this._r.contains(t)&&this._n(t).then(e=>{e.boundingClientRect&&!this.getEntry(t)&&this.entries.set(t,e);this._t||(this._t=requestAnimationFrame(this._rc))})};unobserve=t=>{this.entries.has(t)&&this.entries.delete(t)};_rc=()=>{if(!this.entries.size){this._t=0;return}const{clientWidth:t,clientHeight:e}=this._r,i=new Promise(s=>{const r=[];this.entries.forEach(({target:h,boundingClientRect:o,isIntersecting:u})=>{this._r.contains(h)&&this._n(h).then(n=>{if(!n.isIntersecting){if(this._cm===1)return;if(this._cm===2){u&&(this.entries.set(h,n),r.push(n));return}}const{left:a,top:f}=n.boundingClientRect;(o.top!==f||o.left!==a||this._w!==t||this._h!==e)&&(this.entries.set(h,n),r.push(n))})}),this._w=t,this._h=e,s(r)});this._t=requestAnimationFrame(async()=>{const s=await i;s.length&&this._c(s,this),this._rc()})};_n=t=>new Promise(e=>{new IntersectionObserver(([s],r)=>{r.disconnect(),e(s)},{threshold:this._th,rootMargin:this._rm}).observe(t)});getEntry=t=>this.entries.get(t);disconnect=()=>{cancelAnimationFrame(this._t),this.entries.clear(),this._t=0}};exports.PositionObserver=d;
//# sourceMappingURL=index-DgzRtWFW.js.map
