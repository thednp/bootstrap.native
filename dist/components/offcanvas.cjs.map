{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  MouseEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsDismiss from \"~/strings/dataBsDismiss\";\nimport dataBsToggle from \"~/strings/dataBsToggle\";\nimport showClass from \"~/strings/showClass\";\nimport offcanvasString from \"~/strings/offcanvasString\";\nimport offcanvasComponent from \"~/strings/offcanvasComponent\";\nimport modalComponent from \"~/strings/modalComponent\";\n\nimport getTargetElement from \"~/util/getTargetElement\";\nimport isVisible from \"~/util/isVisible\";\nimport { setScrollbar } from \"~/util/scrollbar\";\nimport { hasPopup } from \"~/util/popupContainer\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"~/util/backdrop\";\nimport isDisabled from \"~/util/isDisabled\";\nimport BaseComponent from \"./base-component\";\nimport { OffcanvasEvent, OffcanvasOptions } from \"~/interface/offcanvas\";\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: Element & EventTarget | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: Element) =>\n  getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: Element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: \"visible\" });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  (element as HTMLElement).blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nfunction offcanvasTriggerHandler(\n  this: HTMLElement,\n  e: MouseEvent<HTMLElement>,\n) {\n  const element = getTargetElement(this);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (isDisabled(this)) return;\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  self.relatedTarget = this;\n  self.toggle();\n\n  // istanbul ignore else @preserve\n  if (this.tagName === \"A\") e.preventDefault();\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent<HTMLElement>) => {\n  const { target } = e;\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target),\n  );\n  // istanbul ignore else @preserve\n  if (!element) return;\n\n  const offCanvasDismiss = querySelector<HTMLElement>(\n    offcanvasDismissSelector,\n    element,\n  );\n  const self = getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  // istanbul ignore if: a filter is required here @preserve\n  if (overlay.contains(target) && backdrop === \"static\") return;\n\n  // istanbul ignore else @preserve\n  if (\n    !(selection && selection.toString().length) &&\n    ((!element.contains(target) &&\n      backdrop &&\n      // istanbul ignore next @preserve\n      (!trigger || triggers.includes(target))) ||\n      (offCanvasDismiss &&\n        offCanvasDismiss.contains(target)))\n  ) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss\n      : undefined;\n    self.hide();\n  }\n\n  // istanbul ignore next @preserve\n  if (trigger && trigger.tagName === \"A\") e.preventDefault();\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  // istanbul ignore else @preserve\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = undefined;\n    self.hide();\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n  setAttribute(element, \"role\", \"dialog\");\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, \"true\");\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, \"role\");\n  setElementStyle(element, { visibility: \"\" });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget ||\n    triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare element: HTMLElement;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: EventTarget & HTMLElement | undefined;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(\n    target: Element | string,\n    config?: Partial<OffcanvasOptions>,\n  ) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [\n      ...querySelectorAll<HTMLElement>(\n        offcanvasToggleSelector,\n        getDocument(element),\n      ),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = undefined;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    // istanbul ignore else @preserve\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, showOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const that = getOffcanvasInstance(currentOpen) ||\n        // istanbul ignore next @preserve\n        getInstance<typeof BaseComponent & { hide: () => void }>(\n          currentOpen,\n          modalComponent,\n        );\n\n      // istanbul ignore else @preserve\n      if (that) that.hide();\n    }\n\n    if (options.backdrop) {\n      if (!hasPopup(overlay)) appendOverlay(element, true);\n      else toggleOverlayType();\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n    } else {\n      beforeOffcanvasShow(this);\n      // istanbul ignore next @preserve - this test was done on Modal\n      if (currentOpen && hasClass(overlay, showClass)) hideOverlay();\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    // istanbul ignore else @preserve\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, hideOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n    beforeOffcanvasHide(this);\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach((btn) => {\n      action(btn, mouseclickEvent, offcanvasTriggerHandler);\n    });\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) emulateTransitionEnd(element, callback);\n    // istanbul ignore next @preserve\n    else callback();\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","getTargetElement","isDisabled","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","trigger","closest","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","querySelectorAll","btn","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}