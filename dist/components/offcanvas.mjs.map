{"version":3,"file":"offcanvas.mjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  MouseEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsDismiss from \"~/strings/dataBsDismiss\";\nimport dataBsToggle from \"~/strings/dataBsToggle\";\nimport showClass from \"~/strings/showClass\";\nimport offcanvasString from \"~/strings/offcanvasString\";\nimport offcanvasComponent from \"~/strings/offcanvasComponent\";\nimport modalComponent from \"~/strings/modalComponent\";\n\nimport getTargetElement from \"~/util/getTargetElement\";\nimport isVisible from \"~/util/isVisible\";\nimport { setScrollbar } from \"~/util/scrollbar\";\nimport { hasPopup } from \"~/util/popupContainer\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"~/util/backdrop\";\nimport isDisabled from \"~/util/isDisabled\";\nimport BaseComponent from \"./base-component\";\nimport { OffcanvasEvent, OffcanvasOptions } from \"~/interface/offcanvas\";\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: Element & EventTarget | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: Element) =>\n  getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: Element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: \"visible\" });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  (element as HTMLElement).blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nfunction offcanvasTriggerHandler(\n  this: HTMLElement,\n  e: MouseEvent<HTMLElement>,\n) {\n  const element = getTargetElement(this);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (isDisabled(this)) return;\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  self.relatedTarget = this;\n  self.toggle();\n\n  // istanbul ignore else @preserve\n  if (this.tagName === \"A\") e.preventDefault();\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent<HTMLElement>) => {\n  const { target } = e;\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target),\n  );\n  // istanbul ignore else @preserve\n  if (!element) return;\n\n  const offCanvasDismiss = querySelector<HTMLElement>(\n    offcanvasDismissSelector,\n    element,\n  );\n  const self = getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  // istanbul ignore if: a filter is required here @preserve\n  if (overlay.contains(target) && backdrop === \"static\") return;\n\n  // istanbul ignore else @preserve\n  if (\n    !(selection && selection.toString().length) &&\n    ((!element.contains(target) &&\n      backdrop &&\n      // istanbul ignore next @preserve\n      (!trigger || triggers.includes(target))) ||\n      (offCanvasDismiss &&\n        offCanvasDismiss.contains(target)))\n  ) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss\n      : undefined;\n    self.hide();\n  }\n\n  // istanbul ignore next @preserve\n  if (trigger && trigger.tagName === \"A\") e.preventDefault();\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  // istanbul ignore else @preserve\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = undefined;\n    self.hide();\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n  setAttribute(element, \"role\", \"dialog\");\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, \"true\");\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, \"role\");\n  setElementStyle(element, { visibility: \"\" });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget ||\n    triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare element: HTMLElement;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: EventTarget & HTMLElement | undefined;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(\n    target: Element | string,\n    config?: Partial<OffcanvasOptions>,\n  ) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [\n      ...querySelectorAll<HTMLElement>(\n        offcanvasToggleSelector,\n        getDocument(element),\n      ),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = undefined;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    // istanbul ignore else @preserve\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, showOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const that = getOffcanvasInstance(currentOpen) ||\n        // istanbul ignore next @preserve\n        getInstance<typeof BaseComponent & { hide: () => void }>(\n          currentOpen,\n          modalComponent,\n        );\n\n      // istanbul ignore else @preserve\n      if (that) that.hide();\n    }\n\n    if (options.backdrop) {\n      if (!hasPopup(overlay)) appendOverlay(element, true);\n      else toggleOverlayType();\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n    } else {\n      beforeOffcanvasShow(this);\n      // istanbul ignore next @preserve - this test was done on Modal\n      if (currentOpen && hasClass(overlay, showClass)) hideOverlay();\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    // istanbul ignore else @preserve\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, hideOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n    beforeOffcanvasHide(this);\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach((btn) => {\n      action(btn, mouseclickEvent, offcanvasTriggerHandler);\n    });\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) emulateTransitionEnd(element, callback);\n    // istanbul ignore next @preserve\n    else callback();\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","getTargetElement","isDisabled","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","trigger","closest","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","querySelectorAll","btn","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}